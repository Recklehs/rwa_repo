{
  "info": {
    "_postman_id": "c7f4dfe5-4ee7-4b94-8d5a-4b5f8f3af3f6",
    "name": "RWA x CryptoOrder AKS User Scenario",
    "description": "AKS 실사용 거래 E2E 시나리오: 판매자/구매자 가입, 지갑 프로비저닝, 컴플라이언스 승인, 자산 세팅, 매물 등록, 매수 체결, 체결 반영 검증.",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "variable": [
    {
      "key": "cryptoorder_base_url",
      "value": "http://<cryptoorder-lb-ip>"
    },
    {
      "key": "rwa_base_url",
      "value": "http://<rwa-lb-ip>"
    },
    {
      "key": "provider",
      "value": "MEMBER"
    },
    {
      "key": "expect_jwks_mode",
      "value": "true"
    },
    {
      "key": "wallet_poll_max_attempts",
      "value": "40"
    },
    {
      "key": "tx_poll_max_attempts",
      "value": "80"
    },
    {
      "key": "listing_poll_max_attempts",
      "value": "80"
    },
    {
      "key": "trades_poll_max_attempts",
      "value": "80"
    },
    {
      "key": "trade_amount_raw",
      "value": "1000000000000"
    },
    {
      "key": "trade_credit_raw",
      "value": "100000000"
    }
  ],
  "item": [
    {
      "name": "0) Health & Public",
      "item": [
        {
          "name": "01 RWA Health",
          "request": {
            "method": "GET",
            "header": [],
            "url": "{{rwa_base_url}}/actuator/health",
            "description": "RWA 서버 health 상태 확인"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const j = pm.response.json();",
                  "pm.test('health is UP', function () { pm.expect(j.status).to.eql('UP'); });"
                ]
              }
            }
          ],
          "description": "RWA 서버 health 상태 확인"
        },
        {
          "name": "02 CryptoOrder Health",
          "request": {
            "method": "GET",
            "header": [],
            "url": "{{cryptoorder_base_url}}/actuator/health",
            "description": "CryptoOrder 서버 health 상태 확인"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const j = pm.response.json();",
                  "pm.test('health is UP', function () { pm.expect(j.status).to.eql('UP'); });"
                ]
              }
            }
          ],
          "description": "CryptoOrder 서버 health 상태 확인"
        },
        {
          "name": "03 CryptoOrder JWKS",
          "request": {
            "method": "GET",
            "header": [],
            "url": "{{cryptoorder_base_url}}/.well-known/jwks.json",
            "description": "CryptoOrder JWKS 엔드포인트 확인"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const j = pm.response.json();",
                  "pm.test('keys is array', function () { pm.expect(Array.isArray(j.keys)).to.eql(true); });",
                  "if ((pm.environment.get('expect_jwks_mode') || pm.collectionVariables.get('expect_jwks_mode') || 'true') === 'true') {",
                  "  pm.test('jwks has key', function () { pm.expect(j.keys.length > 0).to.eql(true); });",
                  "}"
                ]
              }
            }
          ],
          "description": "CryptoOrder JWKS 엔드포인트 확인"
        }
      ]
    },
    {
      "name": "1) Seller Auth Journey",
      "item": [
        {
          "name": "04 Seller Signup",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "{{seller_idem_signup}}"
              }
            ],
            "url": "{{cryptoorder_base_url}}/auth/signup",
            "description": "판매자 회원가입 및 토큰 발급",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"{{seller_name}}\",\n  \"phone\": \"{{seller_phone}}\",\n  \"birthDate\": \"{{seller_birth_date}}\",\n  \"loginId\": \"{{seller_login_id}}\",\n  \"password\": \"{{seller_password}}\",\n  \"provider\": \"{{signup_provider}}\",\n  \"externalUserId\": \"{{seller_external_user_id}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const runId = pm.variables.replaceIn('{{$guid}}');",
                  "const ts = Date.now();",
                  "const seg = () => String(Math.floor(Math.random() * 9000) + 1000);",
                  "pm.collectionVariables.set('run_id', runId);",
                  "pm.collectionVariables.set('signup_provider', pm.environment.get('provider') || pm.collectionVariables.get('provider') || 'MEMBER');",
                  "pm.collectionVariables.set('seller_name', 'Scenario Seller');",
                  "pm.collectionVariables.set('seller_phone', `010-${seg()}-${seg()}`);",
                  "pm.collectionVariables.set('seller_birth_date', '1992-01-01');",
                  "pm.collectionVariables.set('seller_login_id', `seller_${ts}`);",
                  "pm.collectionVariables.set('seller_password', 'Passw0rd!123');",
                  "pm.collectionVariables.set('seller_external_user_id', `seller_ext_${runId}`);",
                  "pm.collectionVariables.set('seller_idem_signup', `seller-signup-${runId}`);",
                  "pm.collectionVariables.set('seller_idem_login', `seller-login-${runId}`);",
                  "pm.collectionVariables.set('seller_idem_refresh', `seller-refresh-${runId}`);",
                  "pm.collectionVariables.set('seller_wallet_poll_attempt', '0');"
                ]
              }
            },
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('seller token payload exists', function () {",
                  "  pm.expect(j.tokenType).to.eql('Bearer');",
                  "  pm.expect(j.accessToken).to.be.a('string').and.not.empty;",
                  "  pm.expect(j.refreshToken).to.be.a('string').and.not.empty;",
                  "  pm.expect(j.userId).to.be.a('string').and.not.empty;",
                  "});",
                  "pm.collectionVariables.set('seller_user_id', j.userId);",
                  "pm.collectionVariables.set('seller_access_token', j.accessToken);",
                  "pm.collectionVariables.set('seller_refresh_token', j.refreshToken);",
                  "pm.collectionVariables.set('seller_active_refresh_token', j.refreshToken);"
                ]
              }
            }
          ],
          "description": "판매자 회원가입 및 토큰 발급"
        },
        {
          "name": "05 Seller Login",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "{{seller_idem_login}}"
              }
            ],
            "url": "{{cryptoorder_base_url}}/auth/login",
            "description": "판매자 로그인",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"loginId\": \"{{seller_login_id}}\",\n  \"password\": \"{{seller_password}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('seller login tokens exist', function () {",
                  "  pm.expect(j.accessToken).to.be.a('string').and.not.empty;",
                  "  pm.expect(j.refreshToken).to.be.a('string').and.not.empty;",
                  "});",
                  "pm.collectionVariables.set('seller_login_access_token', j.accessToken);",
                  "pm.collectionVariables.set('seller_refresh_token', j.refreshToken);",
                  "pm.collectionVariables.set('seller_active_refresh_token', j.refreshToken);"
                ]
              }
            }
          ],
          "description": "판매자 로그인"
        },
        {
          "name": "06 Seller Refresh",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "{{seller_idem_refresh}}"
              }
            ],
            "url": "{{cryptoorder_base_url}}/auth/refresh",
            "description": "판매자 refresh 토큰으로 access 토큰 갱신",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"refreshToken\": \"{{seller_active_refresh_token}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('seller refresh tokens exist', function () {",
                  "  pm.expect(j.accessToken).to.be.a('string').and.not.empty;",
                  "  pm.expect(j.refreshToken).to.be.a('string').and.not.empty;",
                  "  pm.expect(j.userId).to.eql(pm.collectionVariables.get('seller_user_id'));",
                  "});",
                  "pm.collectionVariables.set('seller_bearer_token', j.accessToken);",
                  "pm.collectionVariables.set('seller_active_refresh_token', j.refreshToken);"
                ]
              }
            }
          ],
          "description": "판매자 refresh 토큰으로 access 토큰 갱신"
        }
      ]
    },
    {
      "name": "2) Buyer Auth Journey",
      "item": [
        {
          "name": "07 Buyer Signup",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "{{buyer_idem_signup}}"
              }
            ],
            "url": "{{cryptoorder_base_url}}/auth/signup",
            "description": "구매자 회원가입 및 토큰 발급",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"{{buyer_name}}\",\n  \"phone\": \"{{buyer_phone}}\",\n  \"birthDate\": \"{{buyer_birth_date}}\",\n  \"loginId\": \"{{buyer_login_id}}\",\n  \"password\": \"{{buyer_password}}\",\n  \"provider\": \"{{signup_provider}}\",\n  \"externalUserId\": \"{{buyer_external_user_id}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const runId = pm.collectionVariables.get('run_id') || pm.variables.replaceIn('{{$guid}}');",
                  "const ts = Date.now();",
                  "const seg = () => String(Math.floor(Math.random() * 9000) + 1000);",
                  "pm.collectionVariables.set('run_id', runId);",
                  "pm.collectionVariables.set('buyer_name', 'Scenario Buyer');",
                  "pm.collectionVariables.set('buyer_phone', `010-${seg()}-${seg()}`);",
                  "pm.collectionVariables.set('buyer_birth_date', '1994-02-02');",
                  "pm.collectionVariables.set('buyer_login_id', `buyer_${ts}`);",
                  "pm.collectionVariables.set('buyer_password', 'Passw0rd!123');",
                  "pm.collectionVariables.set('buyer_external_user_id', `buyer_ext_${runId}`);",
                  "pm.collectionVariables.set('buyer_idem_signup', `buyer-signup-${runId}`);",
                  "pm.collectionVariables.set('buyer_idem_login', `buyer-login-${runId}`);",
                  "pm.collectionVariables.set('buyer_idem_refresh', `buyer-refresh-${runId}`);",
                  "pm.collectionVariables.set('buyer_wallet_poll_attempt', '0');"
                ]
              }
            },
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('buyer token payload exists', function () {",
                  "  pm.expect(j.tokenType).to.eql('Bearer');",
                  "  pm.expect(j.accessToken).to.be.a('string').and.not.empty;",
                  "  pm.expect(j.refreshToken).to.be.a('string').and.not.empty;",
                  "  pm.expect(j.userId).to.be.a('string').and.not.empty;",
                  "});",
                  "pm.collectionVariables.set('buyer_user_id', j.userId);",
                  "pm.collectionVariables.set('buyer_access_token', j.accessToken);",
                  "pm.collectionVariables.set('buyer_refresh_token', j.refreshToken);",
                  "pm.collectionVariables.set('buyer_active_refresh_token', j.refreshToken);"
                ]
              }
            }
          ],
          "description": "구매자 회원가입 및 토큰 발급"
        },
        {
          "name": "08 Buyer Login",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "{{buyer_idem_login}}"
              }
            ],
            "url": "{{cryptoorder_base_url}}/auth/login",
            "description": "구매자 로그인",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"loginId\": \"{{buyer_login_id}}\",\n  \"password\": \"{{buyer_password}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('buyer login tokens exist', function () {",
                  "  pm.expect(j.accessToken).to.be.a('string').and.not.empty;",
                  "  pm.expect(j.refreshToken).to.be.a('string').and.not.empty;",
                  "});",
                  "pm.collectionVariables.set('buyer_login_access_token', j.accessToken);",
                  "pm.collectionVariables.set('buyer_refresh_token', j.refreshToken);",
                  "pm.collectionVariables.set('buyer_active_refresh_token', j.refreshToken);"
                ]
              }
            }
          ],
          "description": "구매자 로그인"
        },
        {
          "name": "09 Buyer Refresh",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "{{buyer_idem_refresh}}"
              }
            ],
            "url": "{{cryptoorder_base_url}}/auth/refresh",
            "description": "구매자 refresh 토큰으로 access 토큰 갱신",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"refreshToken\": \"{{buyer_active_refresh_token}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('buyer refresh tokens exist', function () {",
                  "  pm.expect(j.accessToken).to.be.a('string').and.not.empty;",
                  "  pm.expect(j.refreshToken).to.be.a('string').and.not.empty;",
                  "  pm.expect(j.userId).to.eql(pm.collectionVariables.get('buyer_user_id'));",
                  "});",
                  "pm.collectionVariables.set('buyer_bearer_token', j.accessToken);",
                  "pm.collectionVariables.set('buyer_active_refresh_token', j.refreshToken);"
                ]
              }
            }
          ],
          "description": "구매자 refresh 토큰으로 access 토큰 갱신"
        }
      ]
    },
    {
      "name": "3) Wallet Provision & Baseline",
      "item": [
        {
          "name": "10 Poll Seller /me until wallet provisioned",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{seller_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/me",
            "description": "판매자 지갑 프로비저닝 완료까지 /me 폴링"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const code = pm.response.code;",
                  "let body = {};",
                  "try { body = pm.response.json(); } catch (e) { body = {}; }",
                  "if (code === 200) {",
                  "  pm.test('seller userId matches', function () { pm.expect(body.userId).to.eql(pm.collectionVariables.get('seller_user_id')); });",
                  "  pm.test('seller wallet address exists', function () { pm.expect(body.address).to.match(/^0x[a-fA-F0-9]{40}$/); });",
                  "  pm.collectionVariables.set('seller_wallet_address', body.address);",
                  "  pm.collectionVariables.set('seller_wallet_poll_attempt', '0');",
                  "  // continue to next request",
                  "  return;",
                  "}",
                  "if (code === 404 && body.message === 'WALLET_NOT_PROVISIONED') {",
                  "  const current = Number(pm.collectionVariables.get('seller_wallet_poll_attempt') || '0') + 1;",
                  "  const max = Number(pm.environment.get('wallet_poll_max_attempts') || pm.collectionVariables.get('wallet_poll_max_attempts') || '40');",
                  "  pm.collectionVariables.set('seller_wallet_poll_attempt', String(current));",
                  "  if (current < max) {",
                  "    pm.execution.setNextRequest(pm.info.requestName);",
                  "    return;",
                  "  }",
                  "  pm.test('seller wallet provisioned within max attempts', function () {",
                  "    pm.expect.fail(`Still WALLET_NOT_PROVISIONED after ${max} attempts`);",
                  "  });",
                  "  // continue to next request",
                  "  return;",
                  "}",
                  "pm.test('unexpected seller /me response', function () {",
                  "  pm.expect.fail(`Unexpected status=${code}, body=${pm.response.text()}`);",
                  "});",
                  "// continue to next request"
                ]
              }
            }
          ],
          "description": "판매자 지갑 프로비저닝 완료까지 /me 폴링"
        },
        {
          "name": "11 Poll Buyer /me until wallet provisioned",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{buyer_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/me",
            "description": "구매자 지갑 프로비저닝 완료까지 /me 폴링"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const code = pm.response.code;",
                  "let body = {};",
                  "try { body = pm.response.json(); } catch (e) { body = {}; }",
                  "if (code === 200) {",
                  "  pm.test('buyer userId matches', function () { pm.expect(body.userId).to.eql(pm.collectionVariables.get('buyer_user_id')); });",
                  "  pm.test('buyer wallet address exists', function () { pm.expect(body.address).to.match(/^0x[a-fA-F0-9]{40}$/); });",
                  "  pm.collectionVariables.set('buyer_wallet_address', body.address);",
                  "  pm.collectionVariables.set('buyer_wallet_poll_attempt', '0');",
                  "  // continue to next request",
                  "  return;",
                  "}",
                  "if (code === 404 && body.message === 'WALLET_NOT_PROVISIONED') {",
                  "  const current = Number(pm.collectionVariables.get('buyer_wallet_poll_attempt') || '0') + 1;",
                  "  const max = Number(pm.environment.get('wallet_poll_max_attempts') || pm.collectionVariables.get('wallet_poll_max_attempts') || '40');",
                  "  pm.collectionVariables.set('buyer_wallet_poll_attempt', String(current));",
                  "  if (current < max) {",
                  "    pm.execution.setNextRequest(pm.info.requestName);",
                  "    return;",
                  "  }",
                  "  pm.test('buyer wallet provisioned within max attempts', function () {",
                  "    pm.expect.fail(`Still WALLET_NOT_PROVISIONED after ${max} attempts`);",
                  "  });",
                  "  // continue to next request",
                  "  return;",
                  "}",
                  "pm.test('unexpected buyer /me response', function () {",
                  "  pm.expect.fail(`Unexpected status=${code}, body=${pm.response.text()}`);",
                  "});",
                  "// continue to next request"
                ]
              }
            }
          ],
          "description": "구매자 지갑 프로비저닝 완료까지 /me 폴링"
        },
        {
          "name": "12 Seller /me/wallet baseline",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{seller_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/me/wallet",
            "description": "판매자 지갑 baseline 확인"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const j = pm.response.json();",
                  "pm.test('shareApprovalForMarket exists', function () { pm.expect(j).to.have.property('shareApprovalForMarket'); });",
                  "pm.collectionVariables.set('seller_share_approval_before', String(j.shareApprovalForMarket));"
                ]
              }
            }
          ],
          "description": "판매자 지갑 baseline 확인"
        },
        {
          "name": "13 Buyer /me/wallet baseline",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{buyer_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/me/wallet",
            "description": "구매자 지갑 baseline 확인"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const j = pm.response.json();",
                  "pm.test('musdAllowanceToMarket exists', function () { pm.expect(j).to.have.property('musdAllowanceToMarket'); });",
                  "pm.collectionVariables.set('buyer_allowance_before', String(j.musdAllowanceToMarket));"
                ]
              }
            }
          ],
          "description": "구매자 지갑 baseline 확인"
        }
      ]
    },
    {
      "name": "4) Admin Setup",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "type": "text/javascript",
            "exec": [
              "const token = pm.environment.get('admin_token');",
              "if (!token) { throw new Error('environment variable admin_token is required for admin setup'); }"
            ]
          }
        }
      ],
      "item": [
        {
          "name": "14 Approve Seller Compliance",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-Admin-Token",
                "value": "{{admin_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "admin-approve-seller-{{run_id}}"
              }
            ],
            "url": "{{rwa_base_url}}/admin/compliance/approve",
            "description": "판매자 컴플라이언스 승인",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"userId\": \"{{seller_user_id}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('seller approved', function () { pm.expect(j.status).to.eql('APPROVED'); });"
                ]
              }
            }
          ],
          "description": "판매자 컴플라이언스 승인"
        },
        {
          "name": "15 Approve Buyer Compliance",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-Admin-Token",
                "value": "{{admin_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "admin-approve-buyer-{{run_id}}"
              }
            ],
            "url": "{{rwa_base_url}}/admin/compliance/approve",
            "description": "구매자 컴플라이언스 승인",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"userId\": \"{{buyer_user_id}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('buyer approved', function () { pm.expect(j.status).to.eql('APPROVED'); });"
                ]
              }
            }
          ],
          "description": "구매자 컴플라이언스 승인"
        },
        {
          "name": "16 List APPROVED users",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "X-Admin-Token",
                "value": "{{admin_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/admin/compliance/users?status=APPROVED",
            "description": "APPROVED 사용자 목록에 판매자/구매자가 포함되는지 확인"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const arr = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('response is array', function () { pm.expect(Array.isArray(arr)).to.eql(true); });",
                  "const seller = pm.collectionVariables.get('seller_user_id');",
                  "const buyer = pm.collectionVariables.get('buyer_user_id');",
                  "const hasSeller = Array.isArray(arr) && arr.some(v => String(v.userId) === String(seller));",
                  "const hasBuyer = Array.isArray(arr) && arr.some(v => String(v.userId) === String(buyer));",
                  "pm.test('approved list contains seller', function () { pm.expect(hasSeller).to.eql(true); });",
                  "pm.test('approved list contains buyer', function () { pm.expect(hasBuyer).to.eql(true); });"
                ]
              }
            }
          ],
          "description": "APPROVED 사용자 목록에 판매자/구매자가 포함되는지 확인"
        },
        {
          "name": "17 Get issued tokens",
          "request": {
            "method": "GET",
            "header": [],
            "url": "{{rwa_base_url}}/tokens",
            "description": "토큰화된 자산에서 첫 unit/class를 선택"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const arr = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('response is array', function () { pm.expect(Array.isArray(arr)).to.eql(true); });",
                  "if (Array.isArray(arr) && arr.length > 0) {",
                  "  const t = arr[0];",
                  "  pm.test('unitId exists', function () { pm.expect(t.unitId).to.be.a('string').and.not.empty; });",
                  "  pm.test('classId exists', function () { pm.expect(t.classId).to.be.a('string').and.not.empty; });",
                  "  pm.collectionVariables.set('trade_unit_id', t.unitId);",
                  "  pm.collectionVariables.set('trade_class_id', t.classId);",
                  "  pm.collectionVariables.set('bootstrap_needed', 'false');",
                  "  if (t.tokenId !== undefined && t.tokenId !== null) {",
                  "    pm.collectionVariables.set('trade_token_id', String(t.tokenId));",
                  "  }",
                  "  pm.execution.setNextRequest('18 Credit mUSD to Buyer');",
                  "  return;",
                  "}",
                  "pm.collectionVariables.set('bootstrap_needed', 'true');",
                  "const runId = pm.collectionVariables.get('run_id') || pm.variables.replaceIn('{{$guid}}');",
                  "const kaptCode = '99' + String(Date.now()).slice(-8);",
                  "pm.collectionVariables.set('bootstrap_kapt_code', kaptCode);",
                  "pm.collectionVariables.set('bootstrap_import_idem', `bootstrap-import-${runId}-${Date.now()}`);",
                  "pm.collectionVariables.set('bootstrap_tokenize_idem', `bootstrap-tokenize-${runId}-${Date.now()}`);",
                  "pm.collectionVariables.set('bootstrap_units_poll_attempt', '0');",
                  "pm.execution.setNextRequest('17A Bootstrap import complex');"
                ]
              }
            }
          ],
          "description": "토큰화된 자산에서 첫 unit/class를 선택"
        },
        {
          "name": "17A Bootstrap import complex",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-Admin-Token",
                "value": "{{admin_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "{{bootstrap_import_idem}}"
              }
            ],
            "url": "{{rwa_base_url}}/admin/complexes/import",
            "description": "토큰화 자산이 없을 때 테스트용 단지를 생성합니다.",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"rawItemJson\": {\n    \"kaptCode\": \"{{bootstrap_kapt_code}}\",\n    \"kaptName\": \"Codex Bootstrap Complex {{run_id}}\",\n    \"kaptAddr\": \"AKS Bootstrap Address\",\n    \"hoCnt\": 1\n  }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('kaptCode matches', function () { pm.expect(String(j.kaptCode)).to.eql(String(pm.collectionVariables.get('bootstrap_kapt_code'))); });"
                ]
              }
            }
          ],
          "description": "토큰화 자산이 없을 때 테스트용 단지를 생성합니다."
        },
        {
          "name": "17B Bootstrap get classes",
          "request": {
            "method": "GET",
            "header": [],
            "url": "{{rwa_base_url}}/complexes/{{bootstrap_kapt_code}}/classes",
            "description": "생성된 단지의 class를 조회해 trade_class_id를 선택합니다."
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const arr = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('class exists', function () { pm.expect(Array.isArray(arr) && arr.length > 0).to.eql(true); });",
                  "if (Array.isArray(arr) && arr.length > 0) {",
                  "  pm.collectionVariables.set('trade_class_id', arr[0].classId);",
                  "}"
                ]
              }
            }
          ],
          "description": "생성된 단지의 class를 조회해 trade_class_id를 선택합니다."
        },
        {
          "name": "17C Bootstrap tokenize class",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-Admin-Token",
                "value": "{{admin_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "{{bootstrap_tokenize_idem}}"
              }
            ],
            "url": "{{rwa_base_url}}/admin/classes/{{trade_class_id}}/tokenize",
            "description": "선택 class를 토큰화하여 unit tokenId를 생성합니다.",
            "body": {
              "mode": "raw",
              "raw": "{}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('classId matches', function () { pm.expect(String(j.classId)).to.eql(String(pm.collectionVariables.get('trade_class_id'))); });",
                  "pm.test('outboxIds exists', function () { pm.expect(Array.isArray(j.outboxIds) && j.outboxIds.length > 0).to.eql(true); });"
                ]
              }
            }
          ],
          "description": "선택 class를 토큰화하여 unit tokenId를 생성합니다."
        },
        {
          "name": "17D Bootstrap pick tokenized unit",
          "request": {
            "method": "GET",
            "header": [],
            "url": "{{rwa_base_url}}/classes/{{trade_class_id}}/units",
            "description": "tokenId가 생성된 첫 unit을 선택하여 trade_unit_id를 설정합니다."
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const arr = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('units response is array', function () { pm.expect(Array.isArray(arr)).to.eql(true); });",
                  "const picked = Array.isArray(arr) ? arr.find(v => v.tokenId !== null && v.tokenId !== undefined) : null;",
                  "if (picked) {",
                  "  pm.collectionVariables.set('trade_unit_id', picked.unitId);",
                  "  pm.collectionVariables.set('trade_token_id', String(picked.tokenId));",
                  "  pm.collectionVariables.set('bootstrap_units_poll_attempt', '0');",
                  "  return;",
                  "}",
                  "const current = Number(pm.collectionVariables.get('bootstrap_units_poll_attempt') || '0') + 1;",
                  "const max = Number(pm.environment.get('tx_poll_max_attempts') || pm.collectionVariables.get('tx_poll_max_attempts') || '80');",
                  "pm.collectionVariables.set('bootstrap_units_poll_attempt', String(current));",
                  "if (current < max) {",
                  "  pm.execution.setNextRequest(pm.info.requestName);",
                  "  return;",
                  "}",
                  "pm.test('tokenized unit should exist', function () { pm.expect.fail(`No tokenized unit after ${max} attempts`); });"
                ]
              }
            }
          ],
          "description": "tokenId가 생성된 첫 unit을 선택하여 trade_unit_id를 설정합니다."
        },
        {
          "name": "18 Credit mUSD to Buyer",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-Admin-Token",
                "value": "{{admin_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "admin-credit-buyer-musd-{{run_id}}"
              }
            ],
            "url": "{{rwa_base_url}}/admin/wallets/credit/musd",
            "description": "구매자에게 mUSD 지급",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"toUserId\": \"{{buyer_user_id}}\",\n  \"amount\": {{trade_credit_raw}},\n  \"mode\": \"MINT\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('outboxId exists', function () { pm.expect(j.outboxId).to.be.a('string').and.not.empty; });",
                  "pm.collectionVariables.set('admin_credit_outbox_id', j.outboxId);"
                ]
              }
            }
          ],
          "description": "구매자에게 mUSD 지급"
        },
        {
          "name": "19 Distribute shares to Seller",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-Admin-Token",
                "value": "{{admin_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "admin-distribute-seller-shares-{{run_id}}"
              }
            ],
            "url": "{{rwa_base_url}}/admin/distribute/shares",
            "description": "판매자에게 매도용 share 지급",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"toUserId\": \"{{seller_user_id}}\",\n  \"unitId\": \"{{trade_unit_id}}\",\n  \"amount\": {{trade_amount_raw}}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('outboxId exists', function () { pm.expect(j.outboxId).to.be.a('string').and.not.empty; });",
                  "pm.collectionVariables.set('admin_distribute_outbox_id', j.outboxId);",
                  "pm.collectionVariables.set('seller_holdings_poll_attempt', '0');"
                ]
              }
            }
          ],
          "description": "판매자에게 매도용 share 지급"
        },
        {
          "name": "20 Poll Seller Holdings after distribute",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{seller_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/users/{{seller_user_id}}/holdings",
            "description": "분배된 share가 seller holdings에 반영될 때까지 폴링"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const arr = pm.response.json();",
                  "pm.test('response is array', function () { pm.expect(Array.isArray(arr)).to.eql(true); });",
                  "if (Array.isArray(arr) && arr.length > 0) {",
                  "  pm.collectionVariables.set('seller_holdings_after_distribute_count', String(arr.length));",
                  "  pm.collectionVariables.set('seller_holdings_poll_attempt', '0');",
                  "  // continue to next request",
                  "  return;",
                  "}",
                  "const current = Number(pm.collectionVariables.get('seller_holdings_poll_attempt') || '0') + 1;",
                  "const max = Number(pm.environment.get('listing_poll_max_attempts') || pm.collectionVariables.get('listing_poll_max_attempts') || '80');",
                  "pm.collectionVariables.set('seller_holdings_poll_attempt', String(current));",
                  "if (current < max) {",
                  "  pm.execution.setNextRequest(pm.info.requestName);",
                  "  return;",
                  "}",
                  "pm.test('seller holdings should be reflected', function () {",
                  "  pm.expect.fail(`seller holdings still empty after ${max} attempts`);",
                  "});",
                  "// continue to next request"
                ]
              }
            }
          ],
          "description": "분배된 share가 seller holdings에 반영될 때까지 폴링"
        },
        {
          "name": "21 Buyer /me/wallet after credit",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{buyer_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/me/wallet",
            "description": "구매자 mUSD 크레딧 반영 확인"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const j = pm.response.json();",
                  "pm.test('musdBalance exists', function () { pm.expect(j).to.have.property('musdBalance'); });"
                ]
              }
            }
          ],
          "description": "구매자 mUSD 크레딧 반영 확인"
        }
      ]
    },
    {
      "name": "5) Trading E2E",
      "item": [
        {
          "name": "22 Trade List by Seller",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{seller_bearer_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "{{seller_idem_trade_list}}"
              }
            ],
            "url": "{{rwa_base_url}}/trade/list",
            "description": "판매자 매물 등록",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"sellerUserId\": \"{{seller_user_id}}\",\n  \"unitId\": \"{{trade_unit_id}}\",\n  \"amount\": {{trade_amount_raw}},\n  \"unitPrice\": {{trade_unit_price_raw}}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const runId = pm.collectionVariables.get('run_id') || pm.variables.replaceIn('{{$guid}}');",
                  "const price = String(500000000 + Math.floor(Math.random() * 1000000) + (Date.now() % 1000));",
                  "pm.collectionVariables.set('trade_unit_price_raw', price);",
                  "pm.collectionVariables.set('seller_idem_trade_list', `trade-list-${runId}-${Date.now()}`);",
                  "pm.collectionVariables.set('seller_list_poll_attempt', '0');",
                  "pm.collectionVariables.set('seller_approve_poll_attempt', '0');",
                  "pm.collectionVariables.unset('seller_approve_outbox_id');"
                ]
              }
            },
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('outboxIds exists', function () {",
                  "  pm.expect(Array.isArray(j.outboxIds) && j.outboxIds.length >= 1).to.eql(true);",
                  "});",
                  "if (Array.isArray(j.outboxIds) && j.outboxIds.length >= 1) {",
                  "  pm.collectionVariables.set('seller_list_outbox_id', j.outboxIds[j.outboxIds.length - 1]);",
                  "  if (j.outboxIds.length >= 2) {",
                  "    pm.collectionVariables.set('seller_approve_outbox_id', j.outboxIds[0]);",
                  "  }",
                  "}"
                ]
              }
            }
          ],
          "description": "판매자 매물 등록"
        },
        {
          "name": "23 Poll optional seller approval outbox",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{seller_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/tx/outbox/{{seller_poll_outbox_id}}",
            "description": "TRADE_SET_APPROVAL_FOR_ALL outbox(있을 때만) MINED까지 확인"
          },
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const approvalId = pm.collectionVariables.get('seller_approve_outbox_id');",
                  "const listId = pm.collectionVariables.get('seller_list_outbox_id');",
                  "if (approvalId) {",
                  "  pm.collectionVariables.set('seller_approval_outbox_exists', 'true');",
                  "  pm.collectionVariables.set('seller_poll_outbox_id', approvalId);",
                  "} else {",
                  "  pm.collectionVariables.set('seller_approval_outbox_exists', 'false');",
                  "  pm.collectionVariables.set('seller_poll_outbox_id', listId || '');",
                  "}"
                ]
              }
            },
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "if (pm.collectionVariables.get('seller_approval_outbox_exists') !== 'true') {",
                  "  pm.test('approval outbox skipped (already approved)', function () { pm.expect(true).to.eql(true); });",
                  "  pm.execution.setNextRequest('24 Poll seller list outbox');",
                  "  return;",
                  "}",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const j = pm.response.json();",
                  "const status = String(j.status || '').toUpperCase();",
                  "if (status === 'MINED') {",
                  "  pm.test('txType is TRADE_SET_APPROVAL_FOR_ALL', function () { pm.expect(j.txType).to.eql('TRADE_SET_APPROVAL_FOR_ALL'); });",
                  "  pm.collectionVariables.set('seller_approve_poll_attempt', '0');",
                  "  pm.execution.setNextRequest('24 Poll seller list outbox');",
                  "  return;",
                  "}",
                  "if (status === 'FAILED') {",
                  "  pm.test('approval outbox should not fail', function () {",
                  "    pm.expect.fail(`approval outbox failed: ${pm.response.text()}`);",
                  "  });",
                  "  // continue to next request",
                  "  return;",
                  "}",
                  "const current = Number(pm.collectionVariables.get('seller_approve_poll_attempt') || '0') + 1;",
                  "const max = Number(pm.environment.get('tx_poll_max_attempts') || pm.collectionVariables.get('tx_poll_max_attempts') || '80');",
                  "pm.collectionVariables.set('seller_approve_poll_attempt', String(current));",
                  "if (current < max) {",
                  "  pm.execution.setNextRequest(pm.info.requestName);",
                  "  return;",
                  "}",
                  "pm.test('approval outbox mined within max attempts', function () {",
                  "  pm.expect.fail(`approval outbox not mined after ${max} attempts, status=${status}`);",
                  "});",
                  "// continue to next request"
                ]
              }
            }
          ],
          "description": "TRADE_SET_APPROVAL_FOR_ALL outbox(있을 때만) MINED까지 확인"
        },
        {
          "name": "24 Poll seller list outbox",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{seller_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/tx/outbox/{{seller_list_outbox_id}}",
            "description": "TRADE_LIST outbox MINED까지 확인"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const outboxId = pm.collectionVariables.get('seller_list_outbox_id');",
                  "if (!outboxId) {",
                  "  pm.test('seller_list_outbox_id exists', function () { pm.expect.fail('seller_list_outbox_id is missing'); });",
                  "  return;",
                  "}",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "if (pm.response.code !== 200) {",
                  "  return;",
                  "}",
                  "const j = pm.response.json();",
                  "const status = String(j.status || '').toUpperCase();",
                  "if (status === 'MINED') {",
                  "  pm.test('txType is TRADE_LIST', function () { pm.expect(j.txType).to.eql('TRADE_LIST'); });",
                  "  pm.collectionVariables.set('seller_list_poll_attempt', '0');",
                  "  return;",
                  "}",
                  "if (status === 'FAILED') {",
                  "  pm.test('seller list outbox should not fail', function () {",
                  "    pm.expect.fail(`seller list outbox failed: ${pm.response.text()}`);",
                  "  });",
                  "  return;",
                  "}",
                  "const current = Number(pm.collectionVariables.get('seller_list_poll_attempt') || '0') + 1;",
                  "const max = Number(pm.environment.get('tx_poll_max_attempts') || pm.collectionVariables.get('tx_poll_max_attempts') || '80');",
                  "pm.collectionVariables.set('seller_list_poll_attempt', String(current));",
                  "if (current < max) {",
                  "  pm.execution.setNextRequest(pm.info.requestName);",
                  "  return;",
                  "}",
                  "pm.test('seller list outbox mined within max attempts', function () {",
                  "  pm.expect.fail(`seller list outbox not mined after ${max} attempts, status=${status}`);",
                  "});"
                ]
              }
            }
          ],
          "description": "TRADE_LIST outbox MINED까지 확인"
        },
        {
          "name": "25 Seller /me/wallet after list",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{seller_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/me/wallet",
            "description": "매물 등록 후 seller 지갑 승인 상태 확인"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const j = pm.response.json();",
                  "pm.test('shareApprovalForMarket is true', function () { pm.expect(j.shareApprovalForMarket).to.eql(true); });"
                ]
              }
            }
          ],
          "description": "매물 등록 후 seller 지갑 승인 상태 확인"
        },
        {
          "name": "26 Poll listing by classId + unique price",
          "request": {
            "method": "GET",
            "header": [],
            "url": "{{rwa_base_url}}/market/listings?classId={{trade_class_id}}&status=ACTIVE",
            "description": "read-model에서 생성된 listingId를 가격 기준으로 찾아 폴링"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const arr = pm.response.json();",
                  "pm.test('response is array', function () { pm.expect(Array.isArray(arr)).to.eql(true); });",
                  "const targetPrice = String(pm.collectionVariables.get('trade_unit_price_raw'));",
                  "const normalize = (v) => {",
                  "  if (v === null || v === undefined) return \"\";",
                  "  return String(v).trim().replace(/(\\.\\d*?)0+$/, \"$1\").replace(/\\.$/, \"\");",
                  "};",
                  "const found = Array.isArray(arr)",
                  "  ? arr.find(v => normalize(v.price) === normalize(targetPrice))",
                  "  : null;",
                  "if (found) {",
                  "  const listingId = found.id !== undefined ? found.id : found.listingId;",
                  "  if (listingId === undefined || listingId === null) {",
                  "    pm.test('listing id exists', function () { pm.expect.fail('listing found but id is missing'); });",
                  "    // continue to next request",
                  "    return;",
                  "  }",
                  "  pm.collectionVariables.set('listing_id', String(listingId));",
                  "  pm.collectionVariables.set('listing_poll_attempt', '0');",
                  "  // continue to next request",
                  "  return;",
                  "}",
                  "const current = Number(pm.collectionVariables.get('listing_poll_attempt') || '0') + 1;",
                  "const max = Number(pm.environment.get('listing_poll_max_attempts') || pm.collectionVariables.get('listing_poll_max_attempts') || '80');",
                  "pm.collectionVariables.set('listing_poll_attempt', String(current));",
                  "if (current < max) {",
                  "  pm.execution.setNextRequest(pm.info.requestName);",
                  "  return;",
                  "}",
                  "pm.test('listing should appear in read model', function () {",
                  "  pm.expect.fail(`listing not found after ${max} attempts (classId=${pm.collectionVariables.get('trade_class_id')}, price=${targetPrice})`);",
                  "});",
                  "// continue to next request"
                ]
              }
            }
          ],
          "description": "read-model에서 생성된 listingId를 가격 기준으로 찾아 폴링"
        },
        {
          "name": "27 Trade Buy by Buyer",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{buyer_bearer_token}}"
              },
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "{{buyer_idem_trade_buy}}"
              }
            ],
            "url": "{{rwa_base_url}}/trade/buy",
            "description": "구매자 매수 실행",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"buyerUserId\": \"{{buyer_user_id}}\",\n  \"listingId\": {{listing_id}},\n  \"amount\": {{trade_amount_raw}}\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const runId = pm.collectionVariables.get('run_id') || pm.variables.replaceIn('{{$guid}}');",
                  "pm.collectionVariables.set('buyer_idem_trade_buy', `trade-buy-${runId}-${Date.now()}`);",
                  "pm.collectionVariables.set('buyer_buy_poll_attempt', '0');",
                  "pm.collectionVariables.set('buyer_approve_poll_attempt', '0');",
                  "pm.collectionVariables.unset('buyer_approve_outbox_id');"
                ]
              }
            },
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const j = pm.response.json();",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "pm.test('outboxIds exists', function () {",
                  "  pm.expect(Array.isArray(j.outboxIds) && j.outboxIds.length >= 1).to.eql(true);",
                  "});",
                  "if (Array.isArray(j.outboxIds) && j.outboxIds.length >= 1) {",
                  "  pm.collectionVariables.set('buyer_buy_outbox_id', j.outboxIds[j.outboxIds.length - 1]);",
                  "  if (j.outboxIds.length >= 2) {",
                  "    pm.collectionVariables.set('buyer_approve_outbox_id', j.outboxIds[0]);",
                  "  }",
                  "}"
                ]
              }
            }
          ],
          "description": "구매자 매수 실행"
        },
        {
          "name": "28 Poll optional buyer approve outbox",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{buyer_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/tx/outbox/{{buyer_poll_outbox_id}}",
            "description": "TRADE_BUY_APPROVE outbox(있을 때만) MINED까지 확인"
          },
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const approvalId = pm.collectionVariables.get('buyer_approve_outbox_id');",
                  "const buyId = pm.collectionVariables.get('buyer_buy_outbox_id');",
                  "if (approvalId) {",
                  "  pm.collectionVariables.set('buyer_approval_outbox_exists', 'true');",
                  "  pm.collectionVariables.set('buyer_poll_outbox_id', approvalId);",
                  "} else {",
                  "  pm.collectionVariables.set('buyer_approval_outbox_exists', 'false');",
                  "  pm.collectionVariables.set('buyer_poll_outbox_id', buyId || '');",
                  "}"
                ]
              }
            },
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "if (pm.collectionVariables.get('buyer_approval_outbox_exists') !== 'true') {",
                  "  pm.test('buy approve outbox skipped (allowance already sufficient)', function () { pm.expect(true).to.eql(true); });",
                  "  pm.execution.setNextRequest('29 Poll buyer buy outbox');",
                  "  return;",
                  "}",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const j = pm.response.json();",
                  "const status = String(j.status || '').toUpperCase();",
                  "if (status === 'MINED') {",
                  "  pm.test('txType is TRADE_BUY_APPROVE', function () { pm.expect(j.txType).to.eql('TRADE_BUY_APPROVE'); });",
                  "  pm.collectionVariables.set('buyer_approve_poll_attempt', '0');",
                  "  pm.execution.setNextRequest('29 Poll buyer buy outbox');",
                  "  return;",
                  "}",
                  "if (status === 'FAILED') {",
                  "  pm.test('buyer approve outbox should not fail', function () {",
                  "    pm.expect.fail(`buyer approve outbox failed: ${pm.response.text()}`);",
                  "  });",
                  "  // continue to next request",
                  "  return;",
                  "}",
                  "const current = Number(pm.collectionVariables.get('buyer_approve_poll_attempt') || '0') + 1;",
                  "const max = Number(pm.environment.get('tx_poll_max_attempts') || pm.collectionVariables.get('tx_poll_max_attempts') || '80');",
                  "pm.collectionVariables.set('buyer_approve_poll_attempt', String(current));",
                  "if (current < max) {",
                  "  pm.execution.setNextRequest(pm.info.requestName);",
                  "  return;",
                  "}",
                  "pm.test('buyer approve outbox mined within max attempts', function () {",
                  "  pm.expect.fail(`buyer approve outbox not mined after ${max} attempts, status=${status}`);",
                  "});",
                  "// continue to next request"
                ]
              }
            }
          ],
          "description": "TRADE_BUY_APPROVE outbox(있을 때만) MINED까지 확인"
        },
        {
          "name": "29 Poll buyer buy outbox",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{buyer_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/tx/outbox/{{buyer_buy_outbox_id}}",
            "description": "TRADE_BUY outbox MINED까지 확인"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "const outboxId = pm.collectionVariables.get('buyer_buy_outbox_id');",
                  "if (!outboxId) {",
                  "  pm.test('buyer_buy_outbox_id exists', function () { pm.expect.fail('buyer_buy_outbox_id is missing'); });",
                  "  return;",
                  "}",
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "if (pm.response.code !== 200) {",
                  "  return;",
                  "}",
                  "const j = pm.response.json();",
                  "const status = String(j.status || '').toUpperCase();",
                  "if (status === 'MINED') {",
                  "  pm.test('txType is TRADE_BUY', function () { pm.expect(j.txType).to.eql('TRADE_BUY'); });",
                  "  pm.collectionVariables.set('buyer_buy_poll_attempt', '0');",
                  "  return;",
                  "}",
                  "if (status === 'FAILED') {",
                  "  pm.test('buyer buy outbox should not fail', function () {",
                  "    pm.expect.fail(`buyer buy outbox failed: ${pm.response.text()}`);",
                  "  });",
                  "  return;",
                  "}",
                  "const current = Number(pm.collectionVariables.get('buyer_buy_poll_attempt') || '0') + 1;",
                  "const max = Number(pm.environment.get('tx_poll_max_attempts') || pm.collectionVariables.get('tx_poll_max_attempts') || '80');",
                  "pm.collectionVariables.set('buyer_buy_poll_attempt', String(current));",
                  "if (current < max) {",
                  "  pm.execution.setNextRequest(pm.info.requestName);",
                  "  return;",
                  "}",
                  "pm.test('buyer buy outbox mined within max attempts', function () {",
                  "  pm.expect.fail(`buyer buy outbox not mined after ${max} attempts, status=${status}`);",
                  "});"
                ]
              }
            }
          ],
          "description": "TRADE_BUY outbox MINED까지 확인"
        },
        {
          "name": "30 Buyer /me/wallet after buy",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{buyer_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/me/wallet",
            "description": "매수 이후 buyer wallet 상태 확인"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const j = pm.response.json();",
                  "pm.test('musdAllowanceToMarket exists', function () { pm.expect(j).to.have.property('musdAllowanceToMarket'); });"
                ]
              }
            }
          ],
          "description": "매수 이후 buyer wallet 상태 확인"
        },
        {
          "name": "31 Poll Buyer /me/trades includes listing",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{buyer_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/me/trades?limit=20",
            "description": "buyer trades에 해당 listing 체결이 반영될 때까지 폴링"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const arr = pm.response.json();",
                  "pm.test('response is array', function () { pm.expect(Array.isArray(arr)).to.eql(true); });",
                  "const target = String(pm.collectionVariables.get('listing_id'));",
                  "const found = Array.isArray(arr) ? arr.some(v => {",
                  "  const listing = v.listing_id !== undefined ? v.listing_id : v.listingId;",
                  "  return String(listing) === target;",
                  "}) : false;",
                  "if (found) {",
                  "  pm.collectionVariables.set('buyer_trades_poll_attempt', '0');",
                  "  // continue to next request",
                  "  return;",
                  "}",
                  "const current = Number(pm.collectionVariables.get('buyer_trades_poll_attempt') || '0') + 1;",
                  "const max = Number(pm.environment.get('trades_poll_max_attempts') || pm.collectionVariables.get('trades_poll_max_attempts') || '80');",
                  "pm.collectionVariables.set('buyer_trades_poll_attempt', String(current));",
                  "if (current < max) {",
                  "  pm.execution.setNextRequest(pm.info.requestName);",
                  "  return;",
                  "}",
                  "pm.test('buyer trades should include listing', function () {",
                  "  pm.expect.fail(`buyer trades missing listing_id=${target} after ${max} attempts`);",
                  "});",
                  "// continue to next request"
                ]
              }
            }
          ],
          "description": "buyer trades에 해당 listing 체결이 반영될 때까지 폴링"
        },
        {
          "name": "32 Poll Seller /me/trades includes listing",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{seller_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/me/trades?limit=20",
            "description": "seller trades에 해당 listing 체결이 반영될 때까지 폴링"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const arr = pm.response.json();",
                  "pm.test('response is array', function () { pm.expect(Array.isArray(arr)).to.eql(true); });",
                  "const target = String(pm.collectionVariables.get('listing_id'));",
                  "const found = Array.isArray(arr) ? arr.some(v => {",
                  "  const listing = v.listing_id !== undefined ? v.listing_id : v.listingId;",
                  "  return String(listing) === target;",
                  "}) : false;",
                  "if (found) {",
                  "  pm.collectionVariables.set('seller_trades_poll_attempt', '0');",
                  "  // continue to next request",
                  "  return;",
                  "}",
                  "const current = Number(pm.collectionVariables.get('seller_trades_poll_attempt') || '0') + 1;",
                  "const max = Number(pm.environment.get('trades_poll_max_attempts') || pm.collectionVariables.get('trades_poll_max_attempts') || '80');",
                  "pm.collectionVariables.set('seller_trades_poll_attempt', String(current));",
                  "if (current < max) {",
                  "  pm.execution.setNextRequest(pm.info.requestName);",
                  "  return;",
                  "}",
                  "pm.test('seller trades should include listing', function () {",
                  "  pm.expect.fail(`seller trades missing listing_id=${target} after ${max} attempts`);",
                  "});",
                  "// continue to next request"
                ]
              }
            }
          ],
          "description": "seller trades에 해당 listing 체결이 반영될 때까지 폴링"
        },
        {
          "name": "33 Poll Buyer Holdings after buy",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{buyer_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/users/{{buyer_user_id}}/holdings",
            "description": "buy 반영 후 buyer holdings 존재 확인"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const arr = pm.response.json();",
                  "pm.test('response is array', function () { pm.expect(Array.isArray(arr)).to.eql(true); });",
                  "if (Array.isArray(arr) && arr.length > 0) {",
                  "  pm.collectionVariables.set('buyer_holdings_poll_attempt', '0');",
                  "  // continue to next request",
                  "  return;",
                  "}",
                  "const current = Number(pm.collectionVariables.get('buyer_holdings_poll_attempt') || '0') + 1;",
                  "const max = Number(pm.environment.get('trades_poll_max_attempts') || pm.collectionVariables.get('trades_poll_max_attempts') || '80');",
                  "pm.collectionVariables.set('buyer_holdings_poll_attempt', String(current));",
                  "if (current < max) {",
                  "  pm.execution.setNextRequest(pm.info.requestName);",
                  "  return;",
                  "}",
                  "pm.test('buyer holdings should be reflected', function () {",
                  "  pm.expect.fail(`buyer holdings still empty after ${max} attempts`);",
                  "});",
                  "// continue to next request"
                ]
              }
            }
          ],
          "description": "buy 반영 후 buyer holdings 존재 확인"
        },
        {
          "name": "34 Seller Holdings after buy",
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{seller_bearer_token}}"
              }
            ],
            "url": "{{rwa_base_url}}/users/{{seller_user_id}}/holdings",
            "description": "buy 반영 후 seller holdings 조회 (empty 허용)"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const arr = pm.response.json();",
                  "pm.test('response is array', function () { pm.expect(Array.isArray(arr)).to.eql(true); });"
                ]
              }
            }
          ],
          "description": "buy 반영 후 seller holdings 조회 (empty 허용)"
        },
        {
          "name": "35 System data freshness",
          "request": {
            "method": "GET",
            "header": [],
            "url": "{{rwa_base_url}}/system/data-freshness",
            "description": "최종 운영 상태 점검"
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "pm.test('status is 200', function () { pm.response.to.have.status(200); });",
                  "const j = pm.response.json();",
                  "pm.test('response has now', function () { pm.expect(j.now).to.exist; });"
                ]
              }
            }
          ],
          "description": "최종 운영 상태 점검"
        }
      ]
    }
  ]
}
